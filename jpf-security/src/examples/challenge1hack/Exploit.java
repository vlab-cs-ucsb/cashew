package challenge1hack;

import java.util.Collections;
import java.util.Vector;

public class Exploit {

	static final char chars[] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','X','Y','Z','0','1','2','3','4','5','6','7','8','9'};
	static final int MAXLEN = 1000; // 30 for challenge, but can easily do longer.
	
	// not needed for the 'crack3step' attack
	static final String OPEN = "<cookie>";
	static final String CLOSE = "</cookie>";

	/** Exploits the new vulnerability to find which characters are used in the secret */
	static Vector<Character> findUsedChars(String filename) throws Exception {
		Vector<Character> usedChars = new Vector<Character>();
		Vector<Long> sizes = new Vector<Long>(chars.length);
		for (int i = 0; i < chars.length; i++) {
			long size = CRIME.send(filename, null, String.valueOf(chars[i]));
			sizes.add(i,size);
//			System.out.println("Size for " + chars[i] + " = " + size);
		}
		long min = Collections.min(sizes);
		long max = Collections.max(sizes);
		assert(min == max || min == max-1);
		for (int i = 0; i < chars.length; i++) {
			if (sizes.get(i)==max) {
				//the char is used
				usedChars.add(chars[i]);
			}
		}
		return usedChars;
	}

	/** Needed by 'crack3step'. Exponential on 'size'. */
	static Vector<String> permutations(Vector<Character> ch, int size) {
		Vector<String> perms = new Vector<String>();
		if (size==0) {
			perms.add("");
			return perms;
		}
		for (char c : ch) {
			Vector<String> p2 = permutations(ch,size-1);
			for (String s : p2)
				perms.add(c+s);
		}
		return perms;
	}
	
	/** New version that does not require OPEN and CLOSE.
	 * However, it depends on calculating all permutations of 5 of the used chars,
	 * so it only works for secrets with a limited number of used chars (max ~ 28).
	 */
	static String crack3step(String filename) throws Exception {
		Vector<Character> usedChars = findUsedChars(filename);
		System.out.println("Used chars: " + usedChars);
		
		String secret = "";
		long size;
		
		Vector<String> permutations = permutations(usedChars,5);
		long smallest = -1;
		for (String p : permutations) {
//			System.out.println("Trying " + p);
			size = CRIME.send(filename, null, p);
			if (smallest==-1)
				smallest=size;
			else if (size < smallest) {
				secret = p;
				System.out.println("Substring found: " + p);
				break;
			}
		}
		if (secret.length() != 5) {
			System.out.println("No permutation of 5 chars found");
			System.exit(1);
		}
		
		// appending search
		long largest = -1;
		while (secret.length() < MAXLEN) {
			int nope = 0;
			for (char c : usedChars) {
				size = CRIME.send(filename, null, secret+c);
				System.out.println("Size for " + secret+c + " = " + size);
				if (size > largest) {
					largest = size;
				} else if (size < largest) {
					secret += c;
				} else {
					nope++;
				}
			}
			if (nope==usedChars.size())
				break; // no more chars, reverse search
		}
		
		// prepending search
		largest = -1;
		while (secret.length() < MAXLEN) {
			int nope = 0;
			for (char c : usedChars) {
				size = CRIME.send(filename, null, c+secret);
				System.out.println("Size for " + c+secret + " = " + size);
				if (size > largest) {
					largest = size;
				} else if (size < largest) {
					secret = c+secret;
				} else {
					nope++;
				}
			}
			if (nope==usedChars.size())
				break; // no more chars
		}
		
		return secret;
	}
	
	/** New version that first gets all used chars, then searches
	 * for secret between OPEN  and CLOSE */
	static String crack2step(String filename) throws Exception {
		
		Vector<Character> usedChars = findUsedChars(filename);
		System.out.println("Used chars: " + usedChars);
		
		String secret = "";
		long size,sizeWithClose;
		long largest = -1;
		for (int i = 1; i < MAXLEN; i++) {
			for (char c : usedChars) {
				size = CRIME.send(filename, null, OPEN+secret+c);
				System.out.println("Size for " + secret+c + " = " + size);
				if (size > largest) {
					largest = size;
				} else if (size < largest) {
					secret += c;
					sizeWithClose = CRIME.send(filename, null, OPEN+secret+CLOSE);
					if (sizeWithClose <= size)
						return(secret);
					break;
				}
			}
		}
		return secret + " (partial)";
	}

	/** Old verion. Searches for secret enclosed in OPEN and CLOSE, using all allowed characters. **/
	static String crack(String filename) throws Exception {
		String secret = "";
		long size,sizeWithClose;
		long largest = -1;
		for (int i = 1; i < MAXLEN; i++) {
			for (char c : chars) {
				size = CRIME.send(filename, null, OPEN+secret+c);
				System.out.println("Size for " + secret+c + " = " + size);
				if (size > largest) {
					largest = size;
				} else if (size < largest) {
					secret += c;
					sizeWithClose = CRIME.send(filename, null, OPEN+secret+CLOSE);
					if (sizeWithClose <= size)
						return(secret);
					break;
				}
			}
		}
		return secret + " (partial)";
	}

	public static void main(String[] args) throws Exception {
		if (args.length != 1) {
			System.out.println("Usage: java Exploit <filename>");
		} else {
			System.out.println("Cracking secret cookie: " + args[0] + "\n");
			CRIME.initCipher();
			String secret = crack3step(args[0]);
			System.out.println("Secret found: " + secret);
		}
	}
}
